# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/nbs/tools.ipynb (unless otherwise specified).

__all__ = ['human_readable_size', 'size_on_disk', 'wc_py', 'wc_sys', 'lsdir', 'usage_log', 'ResourceMonitor']

# Cell
import os
import subprocess
from glob import glob

# Cell
def human_readable_size(byte_size):
    """Return human-readable size string, using base-10 prefixes."""
    if byte_size < 10**3:
        return f'{byte_size}B'
    if byte_size < 10**6:
        return f'{byte_size / 10**3:.1f}kB'
    if byte_size < 10**9:
        return f'{byte_size / 10**6:.1f}MB'
    return f'{byte_size / 10**9:.1f}GB'

def size_on_disk(*glob_paths):
    """Return total and individual file sizes."""
    result = {'total': None, 'files': []}
    for glob_path in glob_paths:
        for path in glob(glob_path):
            byte_size = os.path.getsize(path)
            human_size = human_readable_size(byte_size)
            result['files'].append((path, byte_size, human_size))
    result['files'].sort(key=lambda x: x[0])
    files_count = len(result['files'])
    total_byte_size = sum(x[1] for x in result['files'])
    total_human_size = human_readable_size(total_byte_size)
    result['total'] = (files_count, total_byte_size, total_human_size)
    return result

# Cell
def wc_py(fpath):
    "Return number of lines in a text file, using Python I/O."
    with open(fpath) as f:
        line_count = 0
        for _ in f:
            line_count += 1
    return line_count

def wc_sys(fpath):
    "Return number of lines in a text file, using sytem 'wc' utility."
    p = subprocess.run(['wc', '-l', fpath], capture_output=True, text=True)
    return int(p.stdout.split()[0])

# Cell
def lsdir(fdir):
    """Return list of strings like "file_name file_size number_of_lines" for all files in :fdir:."""
    fpaths = []
    for fname in os.listdir(fdir):
        fpath = os.path.join(fdir, fname)
        if not os.path.isfile(fpath):
            continue
        fpaths.append(fpath)

    info = ['Name\tLines\tSize']
    for fpath in sorted(fpaths):
        wc = wc_sys(fpath)
        sz = human_readable_size(os.path.getsize(fpath))
        info.append(f'{fpath}\t{wc}\t{sz}')
    return info


# Cell
import sys
import os
import time
import json
import subprocess
import inspect
import warnings

import psutil
from psutil._common import bytes2human

# Cell

def usage_log(pid, interval=1):
    """Regularly write resource usage to stdout."""
    # local imports make function self-sufficient
    import time, psutil

    if psutil.MACOS:
        warnings.warn('Disk I/O stats are not available on MacOS.')

    p = psutil.Process(pid)

    def get_io():
        if psutil.MACOS:
            # io_counters() not available on MacOS
            return (0, 0, 0, 0)
        else:
            x = p.io_counters()
            return (x.read_bytes, x.read_chars, x.write_bytes, x.write_chars)

    print('time,cpu,memory,read_bytes,read_chars,write_bytes,write_chars')
    p.cpu_percent()
    io_before = get_io()
    while True:
        time.sleep(interval)
        io_after = get_io()
        io_rate = tuple((x1 - x0) / interval for x0, x1 in zip(io_before, io_after))
        io_before = io_after
        line = (time.time(), p.cpu_percent(), p.memory_info().rss) + io_rate
        print(','.join(str(x) for x in line))


class ResourceMonitor:
    def __init__(self, pid=None, interval=1):
        self.pid = os.getpid() if pid is None else pid
        self.interval = interval
        self.tags = []

    def start(self):
        code = inspect.getsource(usage_log) + f'\nusage_log({self.pid}, {self.interval})'
        self.process = subprocess.Popen([sys.executable, '-c', code], text=True,
                                        stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    def stop(self):
        self.process.send_signal(subprocess.signal.SIGINT)
        import pandas as pd
        self.process.wait(3)
        df = pd.read_csv(self.process.stdout)
        df['elapsed'] = df['time'] - df.loc[0, 'time']
        self.df = df.set_index('elapsed')

    def tag(self, label):
        self.tags.append((time.time(), label))

    def plot(self):
        import matplotlib.pyplot as plt
        fig, axes = plt.subplots(2, 2, figsize=(12, 8))

        ax = axes[0][0]
        ax.plot(self.df['cpu'])
        ax.set_title('cpu')

        ax = axes[1][0]
        ax.plot(self.df['memory'])
        ax.set_title('memory')
        ax.set_yticklabels([bytes2human(x) for x in ax.get_yticks()])

        ax = axes[0][1]
        ax.plot(self.df['read_bytes'], label='bytes')
        ax.plot(self.df['read_chars'], label='chars')
        ax.set_title('read')
        ax.legend()
        ax.set_yticklabels([bytes2human(x) for x in ax.get_yticks()])

        ax = axes[1][1]
        ax.plot(self.df['write_bytes'], label='bytes')
        ax.plot(self.df['write_chars'], label='chars')
        ax.set_title('write')
        ax.legend()
        ax.set_yticklabels([bytes2human(x) for x in ax.get_yticks()])

        t0 = self.df.loc[0, 'time']
        for ax in axes.flatten():
            y = min(l.get_data()[1].min() for l in ax.lines)
            for tag in self.tags:
                ax.text(tag[0] - t0, y, tag[1], rotation='vertical')

    def dump(self, filepath):
        d = {'tags': self.tags,
             'data': self.df.to_csv()}
        json.dump(d, open(filepath, 'w'))

    @classmethod
    def load(cls, filepath):
        import io
        d = json.load(open(filepath))
        m = cls()
        m.tags = d['tags']
        m.df = pd.read_csv(io.StringIO(d['data'])).set_index('elapsed')
        return m